# =============================================================================
# This piece of code sets the virtual network. For each user, we open an active
# server that simulates this user. It will get requests from the client and send
# files and info
# all servers will have the same ip, but a different port, generated by their
# IP identity
# =============================================================================

import glob
import os
import threading
import socket

# This is the number of virtual users we want to wake up. 
size = 200

operating_system = os.name

# The references should be changed to match your local folders. 
if operating_system == "posix":
    users_path = r'/mnt/c/Users/bitan/code/Virtual_Network/Users/**'

if operating_system == "nt":
    users_path = r'C:\Users\bitan\code\Virtual_Network\Users\**'

IPs_paths = glob.glob(users_path)[:size]
IPs = [os.path.basename(x) for x in IPs_paths]

# This function generates the pseudo-random virtual port of a virtual user by its IP address. 
def ip2port(ip_string):
    number_strings = ip_string.split(".")
    nums = [int(e) for e in number_strings]
    return (7*nums[0] + 11*nums[1] + 13*nums[2] + 19*nums[3] +
            2*nums[1] * nums[3] + 3*nums[0] * nums[2]) % 60000 + 5000


ports = [ip2port(s) for s in IPs]
HEADER = 64
FORMAT = 'utf-8'
SERVER = socket.gethostbyname(socket.gethostname())
DISCONNECT_MSG = "!Disconnect"


def handle_client(conn, addr, ip, addr_in, user_files_names, path):
    print('[SYSTEM] User '+str(ip) +
          ' got a new connection from '+str(addr_in)+'\n')
    connected = True
    while connected:
        msg_length = conn.recv(HEADER).decode(FORMAT)
        if msg_length:
            msg_length = int(msg_length)
            msg = conn.recv(msg_length).decode(FORMAT)
            if msg == DISCONNECT_MSG:
                connected = False
                print(
                    '['+str(addr, ip)+']: User '+str(addr_in)+' disconnected. Server shutting down too.')
            else:
                if msg in user_files_names:
                    with open(path+os.sep+msg, 'rb') as file:
                        data = file.read()
                    conn.send(data)
                    print('['+str(addr, ip)+']: I sent ' +
                          str(msg)+' to '+str(addr_in)+'.\n')
                else:
                    conn.send('!Don\'t_Have_It'.encode(FORMAT))
                    print(
                        '[' + str(addr, ip)+':] User ' + str(addr_in) + ' requested file '+str(msg)+' but I don\'t have it.\n')
    conn.close()


def wake_up_user_as_server(port, ip, path):
    '''the function wakes up the user to serve as a server
    this server can get only one connection
    from one user'''
    user_files_paths = glob.glob(path+os.sep+r'**')
    user_files_names = [os.path.basename(x) for x in user_files_paths]
    addr = (SERVER, port)
    print('[SYSTEM] User '+str(ip) +
          ' is waking up on address ' + str(addr) + '\n')
    # time.sleep(1)
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(addr)
    server.listen()
    print('[SYSTEM] User '+str(ip)+' is listening on '+str(addr)+'\n')
    while True:
        conn, addr_in = server.accept()
        thread = threading.Thread(
            target=handle_client,
            args=(conn, addr, ip, addr_in, user_files_names, path)
        )
        thread.start()
    # server.shutdown(socket.SHUT_RDWR)
    # server.close()


for user_port, user_ip, user_path in zip(ports, IPs, IPs_paths):
    thread = threading.Thread(
        target=wake_up_user_as_server, args=(user_port, user_ip, user_path))
    thread.start()
